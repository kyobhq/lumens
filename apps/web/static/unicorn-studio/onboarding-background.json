{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"fog","usesPingPong":false,"speed":0.2,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"parentLayer":"9839e230-c58a-461e-9c53-e372e41529b9","animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}\nfloat getExponentialWeight(int index) {\nswitch(index) {\ncase 0: return 1.0000000000;\ncase 1: return 0.7165313106;\ncase 2: return 0.5134171190;\ncase 3: return 0.3678794412;\ncase 4: return 0.2636050919;\ncase 5: return 0.1888756057;\ncase 6: return 0.1353352832;\ncase 7: return 0.0969670595;\ncase 8: return 0.0694877157;\ndefault: return 0.0;\n}\n}out vec4 fragColor;const int kernelSize = 36;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}const float PHI = 1.618033988;\nconst float PI = 3.14159265359;float dot_noise(vec3 p) {\nconst mat3 GOLD = mat3(\n-0.571464913, +0.814921382, +0.096597072,\n-0.278044873, -0.303026659, +0.911518454,\n+0.772087367, +0.494042493, +0.399753815);\nreturn dot(cos(GOLD * p), sin(PHI * p * GOLD));\n}float cheap_fbm(vec3 p) {\nmat2 rota = mat2(0.6, -0.8, 0.8, 0.6);\nfloat nos = 0.;\nfloat amp = 1. + 0.5000 * 10.;\nfloat xp = sqrt(2.);\nfloat halfxp = xp * 0.5;\nfor(int i = 0; i < 6; i++) {\nfloat theta = uTime * 0.05 + float(i);\np.xy *= xp;\np.xy += sin(rota * p.xy * xp + theta) * 0.2;\nfloat nz = dot_noise(vec3(p.xy * rota, p.z + theta));\nnos += nz * amp * rota[0][0];\namp *= halfxp;\nrota *= mat2(0.6, -0.8, 0.8, 0.6);\n}\nnos *= 1./float(6);\nfloat density = -3. + 0.5000 * 6.;\nreturn smoothstep(-3., 3., nos + density);\n}float fnoise(vec2 uv) {\nfloat aspectRatio = uResolution.x/uResolution.y;\nvec2 aspect = vec2(aspectRatio, 1);\nfloat multiplier = 10.0 * (0.2000 / ((aspectRatio + 1.) / 2.));\nvec2 st = ((uv * aspect - vec2(0.5014925373134328, 0.004477611940298498) * aspect)) * multiplier * rot((0.0000 - 0.125) * 2. * PI);vec2 mPos = vec2(0.5014925373134328, 0.004477611940298498) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 pos = mix(vec2(0.5014925373134328, 0.004477611940298498), mPos, floor(1.0000));\nfloat dist = ease(0, max(0.,1.-distance(uv * aspect, mPos * aspect) * 4. * (1. - 1.0000)));if (0 == 1) {\ndist = max(0., (0.5 - dist));\n}\nfloat time = uTime * 0.05;\nvec2 drift = vec2(time * 0.2) * 2.0 * 0.5000;\nfloat fbm = cheap_fbm(vec3(st - drift, time)) * dist;\nfbm = fbm / (1. + fbm);\nreturn fbm;\n}vec4 ExponentialBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nfloat total_weight = 0.0;float fogNoise = fnoise(uv);\nfloat radius = 8.0 * fogNoise * max(0.0000, 0.1);\nradius = mix(0.01, 0.03, radius);vec2 dir = normalize(direction) / vec2(uResolution.x/uResolution.y, 1);vec4 center = texture(tex, uv);\nfloat center_weight = getExponentialWeight(0);\ncolor += center * center_weight;\ntotal_weight += center_weight;for (int i = 1; i <= 8; i++) {\nfloat weight = getExponentialWeight(i);\nfloat offset = radius * float(i) / 8.0;\nvec4 sample1 = texture(tex, uv + offset * dir);\nvec4 sample2 = texture(tex, uv - offset * dir);\ncolor += (sample1 + sample2) * weight;\ntotal_weight += 2.0 * weight;\n}\nfloat scatter = radius * 2.;\ncolor += (\ntexture(tex, uv + scatter * dir) +\ntexture(tex, uv - scatter * dir)\n) * 0.0694877157;return color / total_weight;\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn ExponentialBlur(uTexture, uv, direction);\n}vec4 getColor(vec2 uv) {\nreturn blur(uv, vec2(1, 0));\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}\nfloat getExponentialWeight(int index) {\nswitch(index) {\ncase 0: return 1.0000000000;\ncase 1: return 0.7165313106;\ncase 2: return 0.5134171190;\ncase 3: return 0.3678794412;\ncase 4: return 0.2636050919;\ncase 5: return 0.1888756057;\ncase 6: return 0.1353352832;\ncase 7: return 0.0969670595;\ncase 8: return 0.0694877157;\ndefault: return 0.0;\n}\n}out vec4 fragColor;const int kernelSize = 36;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}const float PHI = 1.618033988;\nconst float PI = 3.14159265359;float dot_noise(vec3 p) {\nconst mat3 GOLD = mat3(\n-0.571464913, +0.814921382, +0.096597072,\n-0.278044873, -0.303026659, +0.911518454,\n+0.772087367, +0.494042493, +0.399753815);\nreturn dot(cos(GOLD * p), sin(PHI * p * GOLD));\n}float cheap_fbm(vec3 p) {\nmat2 rota = mat2(0.6, -0.8, 0.8, 0.6);\nfloat nos = 0.;\nfloat amp = 1. + 0.5000 * 10.;\nfloat xp = sqrt(2.);\nfloat halfxp = xp * 0.5;\nfor(int i = 0; i < 6; i++) {\nfloat theta = uTime * 0.05 + float(i);\np.xy *= xp;\np.xy += sin(rota * p.xy * xp + theta) * 0.2;\nfloat nz = dot_noise(vec3(p.xy * rota, p.z + theta));\nnos += nz * amp * rota[0][0];\namp *= halfxp;\nrota *= mat2(0.6, -0.8, 0.8, 0.6);\n}\nnos *= 1./float(6);\nfloat density = -3. + 0.5000 * 6.;\nreturn smoothstep(-3., 3., nos + density);\n}float fnoise(vec2 uv) {\nfloat aspectRatio = uResolution.x/uResolution.y;\nvec2 aspect = vec2(aspectRatio, 1);\nfloat multiplier = 10.0 * (0.2000 / ((aspectRatio + 1.) / 2.));\nvec2 st = ((uv * aspect - vec2(0.5014925373134328, 0.004477611940298498) * aspect)) * multiplier * rot((0.0000 - 0.125) * 2. * PI);vec2 mPos = vec2(0.5014925373134328, 0.004477611940298498) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 pos = mix(vec2(0.5014925373134328, 0.004477611940298498), mPos, floor(1.0000));\nfloat dist = ease(0, max(0.,1.-distance(uv * aspect, mPos * aspect) * 4. * (1. - 1.0000)));if (0 == 1) {\ndist = max(0., (0.5 - dist));\n}\nfloat time = uTime * 0.05;\nvec2 drift = vec2(time * 0.2) * 2.0 * 0.5000;\nfloat fbm = cheap_fbm(vec3(st - drift, time)) * dist;\nfbm = fbm / (1. + fbm);\nreturn fbm;\n}vec4 ExponentialBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nfloat total_weight = 0.0;float fogNoise = fnoise(uv);\nfloat radius = 8.0 * fogNoise * max(0.0000, 0.1);\nradius = mix(0.01, 0.03, radius);vec2 dir = normalize(direction) / vec2(uResolution.x/uResolution.y, 1);vec4 center = texture(tex, uv);\nfloat center_weight = getExponentialWeight(0);\ncolor += center * center_weight;\ntotal_weight += center_weight;for (int i = 1; i <= 8; i++) {\nfloat weight = getExponentialWeight(i);\nfloat offset = radius * float(i) / 8.0;\nvec4 sample1 = texture(tex, uv + offset * dir);\nvec4 sample2 = texture(tex, uv - offset * dir);\ncolor += (sample1 + sample2) * weight;\ntotal_weight += 2.0 * weight;\n}\nfloat scatter = radius * 2.;\ncolor += (\ntexture(tex, uv + scatter * dir) +\ntexture(tex, uv - scatter * dir)\n) * 0.0694877157;return color / total_weight;\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn ExponentialBlur(uTexture, uv, direction);\n}vec4 getColor(vec2 uv) {\nreturn blur(uv, vec2(0, 1));\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}\nfloat getExponentialWeight(int index) {\nswitch(index) {\ncase 0: return 1.0000000000;\ncase 1: return 0.7165313106;\ncase 2: return 0.5134171190;\ncase 3: return 0.3678794412;\ncase 4: return 0.2636050919;\ncase 5: return 0.1888756057;\ncase 6: return 0.1353352832;\ncase 7: return 0.0969670595;\ncase 8: return 0.0694877157;\ndefault: return 0.0;\n}\n}out vec4 fragColor;const int kernelSize = 36;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}const float PHI = 1.618033988;\nconst float PI = 3.14159265359;float dot_noise(vec3 p) {\nconst mat3 GOLD = mat3(\n-0.571464913, +0.814921382, +0.096597072,\n-0.278044873, -0.303026659, +0.911518454,\n+0.772087367, +0.494042493, +0.399753815);\nreturn dot(cos(GOLD * p), sin(PHI * p * GOLD));\n}float cheap_fbm(vec3 p) {\nmat2 rota = mat2(0.6, -0.8, 0.8, 0.6);\nfloat nos = 0.;\nfloat amp = 1. + 0.5000 * 10.;\nfloat xp = sqrt(2.);\nfloat halfxp = xp * 0.5;\nfor(int i = 0; i < 6; i++) {\nfloat theta = uTime * 0.05 + float(i);\np.xy *= xp;\np.xy += sin(rota * p.xy * xp + theta) * 0.2;\nfloat nz = dot_noise(vec3(p.xy * rota, p.z + theta));\nnos += nz * amp * rota[0][0];\namp *= halfxp;\nrota *= mat2(0.6, -0.8, 0.8, 0.6);\n}\nnos *= 1./float(6);\nfloat density = -3. + 0.5000 * 6.;\nreturn smoothstep(-3., 3., nos + density);\n}float fnoise(vec2 uv) {\nfloat aspectRatio = uResolution.x/uResolution.y;\nvec2 aspect = vec2(aspectRatio, 1);\nfloat multiplier = 10.0 * (0.2000 / ((aspectRatio + 1.) / 2.));\nvec2 st = ((uv * aspect - vec2(0.5014925373134328, 0.004477611940298498) * aspect)) * multiplier * rot((0.0000 - 0.125) * 2. * PI);vec2 mPos = vec2(0.5014925373134328, 0.004477611940298498) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 pos = mix(vec2(0.5014925373134328, 0.004477611940298498), mPos, floor(1.0000));\nfloat dist = ease(0, max(0.,1.-distance(uv * aspect, mPos * aspect) * 4. * (1. - 1.0000)));if (0 == 1) {\ndist = max(0., (0.5 - dist));\n}\nfloat time = uTime * 0.05;\nvec2 drift = vec2(time * 0.2) * 2.0 * 0.5000;\nfloat fbm = cheap_fbm(vec3(st - drift, time)) * dist;\nfbm = fbm / (1. + fbm);\nreturn fbm;\n}vec4 ExponentialBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nfloat total_weight = 0.0;float fogNoise = fnoise(uv);\nfloat radius = 8.0 * fogNoise * max(0.0000, 0.1);\nradius = mix(0.01, 0.03, radius);vec2 dir = normalize(direction) / vec2(uResolution.x/uResolution.y, 1);vec4 center = texture(tex, uv);\nfloat center_weight = getExponentialWeight(0);\ncolor += center * center_weight;\ntotal_weight += center_weight;for (int i = 1; i <= 8; i++) {\nfloat weight = getExponentialWeight(i);\nfloat offset = radius * float(i) / 8.0;\nvec4 sample1 = texture(tex, uv + offset * dir);\nvec4 sample2 = texture(tex, uv - offset * dir);\ncolor += (sample1 + sample2) * weight;\ntotal_weight += 2.0 * weight;\n}\nfloat scatter = radius * 2.;\ncolor += (\ntexture(tex, uv + scatter * dir) +\ntexture(tex, uv - scatter * dir)\n) * 0.0694877157;return color / total_weight;\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn ExponentialBlur(uTexture, uv, direction);\n}vec4 getColor(vec2 uv) {\nreturn blur(uv, vec2(1, 1));\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}\nfloat getExponentialWeight(int index) {\nswitch(index) {\ncase 0: return 1.0000000000;\ncase 1: return 0.7165313106;\ncase 2: return 0.5134171190;\ncase 3: return 0.3678794412;\ncase 4: return 0.2636050919;\ncase 5: return 0.1888756057;\ncase 6: return 0.1353352832;\ncase 7: return 0.0969670595;\ncase 8: return 0.0694877157;\ndefault: return 0.0;\n}\n}out vec4 fragColor;const int kernelSize = 36;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}const float PHI = 1.618033988;\nconst float PI = 3.14159265359;float dot_noise(vec3 p) {\nconst mat3 GOLD = mat3(\n-0.571464913, +0.814921382, +0.096597072,\n-0.278044873, -0.303026659, +0.911518454,\n+0.772087367, +0.494042493, +0.399753815);\nreturn dot(cos(GOLD * p), sin(PHI * p * GOLD));\n}float cheap_fbm(vec3 p) {\nmat2 rota = mat2(0.6, -0.8, 0.8, 0.6);\nfloat nos = 0.;\nfloat amp = 1. + 0.5000 * 10.;\nfloat xp = sqrt(2.);\nfloat halfxp = xp * 0.5;\nfor(int i = 0; i < 6; i++) {\nfloat theta = uTime * 0.05 + float(i);\np.xy *= xp;\np.xy += sin(rota * p.xy * xp + theta) * 0.2;\nfloat nz = dot_noise(vec3(p.xy * rota, p.z + theta));\nnos += nz * amp * rota[0][0];\namp *= halfxp;\nrota *= mat2(0.6, -0.8, 0.8, 0.6);\n}\nnos *= 1./float(6);\nfloat density = -3. + 0.5000 * 6.;\nreturn smoothstep(-3., 3., nos + density);\n}float fnoise(vec2 uv) {\nfloat aspectRatio = uResolution.x/uResolution.y;\nvec2 aspect = vec2(aspectRatio, 1);\nfloat multiplier = 10.0 * (0.2000 / ((aspectRatio + 1.) / 2.));\nvec2 st = ((uv * aspect - vec2(0.5014925373134328, 0.004477611940298498) * aspect)) * multiplier * rot((0.0000 - 0.125) * 2. * PI);vec2 mPos = vec2(0.5014925373134328, 0.004477611940298498) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 pos = mix(vec2(0.5014925373134328, 0.004477611940298498), mPos, floor(1.0000));\nfloat dist = ease(0, max(0.,1.-distance(uv * aspect, mPos * aspect) * 4. * (1. - 1.0000)));if (0 == 1) {\ndist = max(0., (0.5 - dist));\n}\nfloat time = uTime * 0.05;\nvec2 drift = vec2(time * 0.2) * 2.0 * 0.5000;\nfloat fbm = cheap_fbm(vec3(st - drift, time)) * dist;\nfbm = fbm / (1. + fbm);\nreturn fbm;\n}vec4 ExponentialBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nfloat total_weight = 0.0;float fogNoise = fnoise(uv);\nfloat radius = 8.0 * fogNoise * max(0.0000, 0.1);\nradius = mix(0.01, 0.03, radius);vec2 dir = normalize(direction) / vec2(uResolution.x/uResolution.y, 1);vec4 center = texture(tex, uv);\nfloat center_weight = getExponentialWeight(0);\ncolor += center * center_weight;\ntotal_weight += center_weight;for (int i = 1; i <= 8; i++) {\nfloat weight = getExponentialWeight(i);\nfloat offset = radius * float(i) / 8.0;\nvec4 sample1 = texture(tex, uv + offset * dir);\nvec4 sample2 = texture(tex, uv - offset * dir);\ncolor += (sample1 + sample2) * weight;\ntotal_weight += 2.0 * weight;\n}\nfloat scatter = radius * 2.;\ncolor += (\ntexture(tex, uv + scatter * dir) +\ntexture(tex, uv - scatter * dir)\n) * 0.0694877157;return color / total_weight;\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn ExponentialBlur(uTexture, uv, direction);\n}vec4 getColor(vec2 uv) {\nreturn blur(uv, vec2(1, -1));\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform sampler2D uBgTexture;\nuniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}\nuvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}out vec4 fragColor;const int kernelSize = 36;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}vec3 Tonemap_ACES(vec3 x) {\nconst float a = 2.51;\nconst float b = 0.03;\nconst float c = 2.43;\nconst float d = 0.59;\nconst float e = 0.14;\nreturn (x * (a * x + b)) / (x * (c * x + d) + e);\n}vec3 chromatic_aberration(vec3 color, vec2 uv, float amount) {\nvec2 offset = normalize(vTextureCoord - 0.5) * amount / vec2(uResolution.x/uResolution.y, 1);\nvec4 left = texture(uTexture, uv - offset);\nvec4 right = texture(uTexture, uv + offset);color.r = left.r;\ncolor.b = right.b;return color;\n}const float PHI = 1.618033988;\nconst float PI = 3.14159265359;float dot_noise(vec3 p) {\nconst mat3 GOLD = mat3(\n-0.571464913, +0.814921382, +0.096597072,\n-0.278044873, -0.303026659, +0.911518454,\n+0.772087367, +0.494042493, +0.399753815);\nreturn dot(cos(GOLD * p), sin(PHI * p * GOLD));\n}float cheap_fbm(vec3 p) {\nmat2 rota = mat2(0.6, -0.8, 0.8, 0.6);\nfloat nos = 0.;\nfloat amp = 1. + 0.5000 * 10.;\nfloat xp = sqrt(2.);\nfloat halfxp = xp * 0.5;\nfor(int i = 0; i < 6; i++) {\nfloat theta = uTime * 0.05 + float(i);\np.xy *= xp;\np.xy += sin(rota * p.xy * xp + theta) * 0.2;\nfloat nz = dot_noise(vec3(p.xy * rota, p.z + theta));\nnos += nz * amp * rota[0][0];\namp *= halfxp;\nrota *= mat2(0.6, -0.8, 0.8, 0.6);\n}\nnos *= 1./float(6);\nfloat density = -3. + 0.5000 * 6.;\nreturn smoothstep(-3., 3., nos + density);\n}float fnoise(vec2 uv) {\nfloat aspectRatio = uResolution.x/uResolution.y;\nvec2 aspect = vec2(aspectRatio, 1);\nfloat multiplier = 10.0 * (0.2000 / ((aspectRatio + 1.) / 2.));\nvec2 st = ((uv * aspect - vec2(0.5014925373134328, 0.004477611940298498) * aspect)) * multiplier * rot((0.0000 - 0.125) * 2. * PI);vec2 mPos = vec2(0.5014925373134328, 0.004477611940298498) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 pos = mix(vec2(0.5014925373134328, 0.004477611940298498), mPos, floor(1.0000));\nfloat dist = ease(0, max(0.,1.-distance(uv * aspect, mPos * aspect) * 4. * (1. - 1.0000)));if (0 == 1) {\ndist = max(0., (0.5 - dist));\n}\nfloat time = uTime * 0.05;\nvec2 drift = vec2(time * 0.2) * 2.0 * 0.5000;\nfloat fbm = cheap_fbm(vec3(st - drift, time)) * dist;\nfbm = fbm / (1. + fbm);\nreturn fbm;\n}vec4 fogComposite(vec2 uv) {\nvec4 bg = texture(uBgTexture, uv);\nvec4 blur = texture(uTexture, uv);\nfloat aspectRatio = uResolution.x/uResolution.y;\nfloat fogNoise = fnoise(uv);\nfloat fogMask = clamp(fogNoise * 2., 0., 1.);vec3 grain = vec3(randFibo(uv + fogNoise));blur.rgb = chromatic_aberration(blur.rgb, uv, fogMask * 0.01 * 0.0000 * (0.2500 * 2.5));\nblur.rgb = Tonemap_ACES(blur.rgb * (0.2000 + 0.5)) + grain * 0.05;\nvec4 foggedBlur = vec4(blur.rgb * vec3(0.9803921568627451, 0.9803921568627451, 0.9803921568627451), blur.a);\nfoggedBlur.rgb += (0.1000 * 0.25 * fogMask * vec3(0.9803921568627451, 0.9803921568627451, 0.9803921568627451));\nfoggedBlur = mix(bg, foggedBlur, fogMask);\nreturn foggedBlur;\n}vec4 getColor(vec2 uv) {\nreturn fogComposite(uv);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"downSample":0.25,"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"downSample":0.25},{"prop":"pass","value":2,"downSample":0.25},{"prop":"pass","value":3,"downSample":0.25},{"prop":"pass","value":4,"includeBg":true}]},"id":"effect"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"flowField","usesPingPong":false,"speed":0.15,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"parentLayer":"804d3c0e-7dde-424a-9b63-b488596e28e2","animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}vec3 hash33(vec3 p3) {\np3 = fract(p3 * vec3(0.1031, 0.11369, 0.13787));\np3 += dot(p3, p3.yxz + 19.19);\nreturn -1.0 + 2.0 * fract(vec3(\n(p3.x + p3.y) * p3.z,\n(p3.x + p3.z) * p3.y,\n(p3.y + p3.z) * p3.x\n));\n}float perlin_noise(vec3 p) {\nvec3 pi = floor(p);\nvec3 pf = p - pi;vec3 w = pf * pf * (3.0 - 2.0 * pf);float n000 = dot(pf - vec3(0.0, 0.0, 0.0), hash33(pi + vec3(0.0, 0.0, 0.0)));\nfloat n100 = dot(pf - vec3(1.0, 0.0, 0.0), hash33(pi + vec3(1.0, 0.0, 0.0)));\nfloat n010 = dot(pf - vec3(0.0, 1.0, 0.0), hash33(pi + vec3(0.0, 1.0, 0.0)));\nfloat n110 = dot(pf - vec3(1.0, 1.0, 0.0), hash33(pi + vec3(1.0, 1.0, 0.0)));\nfloat n001 = dot(pf - vec3(0.0, 0.0, 1.0), hash33(pi + vec3(0.0, 0.0, 1.0)));\nfloat n101 = dot(pf - vec3(1.0, 0.0, 1.0), hash33(pi + vec3(1.0, 0.0, 1.0)));\nfloat n011 = dot(pf - vec3(0.0, 1.0, 1.0), hash33(pi + vec3(0.0, 1.0, 1.0)));\nfloat n111 = dot(pf - vec3(1.0, 1.0, 1.0), hash33(pi + vec3(1.0, 1.0, 1.0)));float nx00 = mix(n000, n100, w.x);\nfloat nx01 = mix(n001, n101, w.x);\nfloat nx10 = mix(n010, n110, w.x);\nfloat nx11 = mix(n011, n111, w.x);float nxy0 = mix(nx00, nx10, w.y);\nfloat nxy1 = mix(nx01, nx11, w.y);float nxyz = mix(nxy0, nxy1, w.z);return nxyz;\n}const float MAX_ITERATIONS = 16.;\nvec2 flow (in vec2 st) {\nfloat aspectRatio = uResolution.x/uResolution.y;vec2 mPos = vec2(0.5014925373134329, 0.25522388059701484) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 pos = mix(vec2(0.5014925373134329, 0.25522388059701484), mPos, floor(1.0000));\nfloat dist = ease(0, max(0.,1. - distance(st * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.0000)));float sprd = (0.3000 + 0.01) / ((aspectRatio + 1.) / 2.);\nfloat amt = 0.0500 * 0.01 * dist;\nif(amt <= 0.) {\nreturn st;\n}vec2 invPos = 1. - pos;\nfloat freq = 5. * sprd;\nfloat t = 0.2000*5. + uTime/60.;\nfloat degrees = 360. * (0.5000 * 6.);\nfloat radians = degrees * 3.1415926 / 180.;for (float i = 0.; i < MAX_ITERATIONS; i++) {\nvec2 scaled = (st - 0.5) * vec2(aspectRatio, 1) + invPos;\nfloat perlin = perlin_noise(vec3((scaled - 0.5) * freq, t)) - 0.5;\nfloat ang = perlin * radians;\nst += vec2(cos(ang), sin(ang)) * amt;\nst = clamp(st, 0., 1.);\n}return st;\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec4 color = texture(uTexture, mix(uv, flow(uv), 0.1000));\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect1"},{"breakpoints":[{"name":"Desktop","min":992,"props":{"width":1445.4295220213849,"left":0.4995036381870191,"top":0.5},"max":null},{"max":991,"props":{"width":1515.667917833503,"left":0.4994791666666667,"top":0.5222743135280711},"name":"Tablet","min":576}],"visible":true,"locked":false,"aspectRatio":1.539714867617108,"layerName":"","userDownsample":1,"isElement":true,"opacity":1,"effects":["9839e230-c58a-461e-9c53-e372e41529b9","804d3c0e-7dde-424a-9b63-b488596e28e2"],"displace":0,"trackMouse":0,"anchorPoint":"center","mouseMomentum":0,"blendMode":"NORMAL","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"maskDepthLayer":1,"dispersion":0,"axisTilt":0,"states":{"appear":[],"scroll":[],"hover":[]},"layerType":"image","imageLoaded":false,"width":1445.4295220213849,"widthMode":"fixed","height":938.7644117890211,"heightMode":"auto","left":0.4995036381870191,"leftMode":"relative","top":0.5,"topMode":"relative","rotation":0,"trackAxes":"xy","fitToCanvas":1,"exposure":0,"saturation":1,"contrast":1,"src":"https://assets.unicorn.studio/images/xzVjNNl3XjTlmqKnikIwFR6zfD92/Mask%20group.webp","naturalWidth":3024,"naturalHeight":1964,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nin vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform vec2 uMousePos;\nuniform sampler2D uBgTexture;\nuniform sampler2D uTexture;\nuniform int uSampleBg;const float STEPS = 24.0;\nconst float PI = 3.1415926;out vec4 fragColor;vec4 getNormalOutput(vec4 color, vec4 background) {\ncolor = mix(background, color + background * (1.0 - color.a), 1.0000);\nreturn color;\n}vec4 getOutputByMode(vec4 color, vec4 background) {\nreturn getNormalOutput(color, background);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0000);uv -= pos;vec4 background = vec4(0);\nif(uSampleBg == 1) {\nbackground = texture(uBgTexture, vTextureCoord);\n}\nvec4 color = texture(uTexture, uv);color.rgb = clamp(color.rgb, 0.0, 1.0);vec4 col = getOutputByMode(color, background);fragColor = col;\n}"],"compiledVertexShaders":["#version 300 es\nprecision highp float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;\nuniform vec2 uMousePos;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\nfloat angleX = uMousePos.y * 0.5 - 0.25;\nfloat angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0,\n0.0, cos(angleX), -sin(angleX), 0.0,\n0.0, sin(angleX), cos(angleX), 0.0,\n0.0, 0.0, 0.0, 1.0);\nmat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0,\n0.0, 1.0, 0.0, 0.0,\n-sin(angleY), 0.0, cos(angleY), 0.0,\n0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY;\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz;\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"uniforms":{}},"id":"image"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"caustics","usesPingPong":false,"speed":0.1,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"parentLayer":"304da7ce-53ab-46cd-9f2b-e3f2b9b522fd","animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nin vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform float uTime;uniform vec2 uMousePos;\nuniform vec2 uResolution;vec4 permute(vec4 t) {\nreturn t * (t * 34.0 + 133.0);\n}vec3 grad(float hash) {\nvec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0;\nvec3 cuboct = cube;float index0 = step(0.0, 1.0 - floor(hash / 16.0));\nfloat index1 = step(0.0, floor(hash / 16.0) - 1.0);cuboct.x *= 1.0 - index0;\ncuboct.y *= 1.0 - index1;\ncuboct.z *= 1.0 - (1.0 - index0 - index1);float type = mod(floor(hash / 8.0), 2.0);\nvec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));vec3 grad = cuboct * 1.22474487139 + rhomb;grad *= (1.0 - 0.042942436724648037 * type) * 3.5946317686139184;return grad;\n}\nvec4 bccNoiseDerivativesPart(vec3 X) {\nvec3 b = floor(X);\nvec4 i4 = vec4(X - b, 2.5);\nvec3 v1 = b + floor(dot(i4, vec4(.25)));\nvec3 v2 = b + vec3(1, 0, 0) + vec3(-1, 1, 1) * floor(dot(i4, vec4(-.25, .25, .25, .35)));\nvec3 v3 = b + vec3(0, 1, 0) + vec3(1, -1, 1) * floor(dot(i4, vec4(.25, -.25, .25, .35)));\nvec3 v4 = b + vec3(0, 0, 1) + vec3(1, 1, -1) * floor(dot(i4, vec4(.25, .25, -.25, .35)));\nvec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0));\nhashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0));\nhashes = mod(permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)), 48.0);\nvec3 d1 = X - v1; vec3 d2 = X - v2; vec3 d3 = X - v3; vec3 d4 = X - v4;\nvec4 a = max(0.75 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0);\nvec4 aa = a * a; vec4 aaaa = aa * aa;\nvec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y);\nvec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w);\nvec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4));\nvec3 derivative = -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations)\n+ mat4x3(g1, g2, g3, g4) * aaaa;\nreturn vec4(derivative, dot(aaaa, extrapolations));\n}\nvec4 bccNoiseDerivatives_XYBeforeZ(vec3 X) {\nmat3 orthonormalMap = mat3(\n0.788675134594813, -0.211324865405187, -0.577350269189626,\n-0.211324865405187, 0.788675134594813, -0.577350269189626,\n0.577350269189626, 0.577350269189626, 0.577350269189626);\nX = orthonormalMap * X;\nvec4 result = bccNoiseDerivativesPart(X) + bccNoiseDerivativesPart(X + 144.5);\nreturn vec4(result.xyz * orthonormalMap, result.w);\n}float ease (int easingFunc, float t) {\nreturn t;\n}vec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn src;\n}const float PI = 3.14159265359;vec4 normalizeNoise(vec4 noise, float amount) {\nreturn mix(noise, (noise + 0.5) * 0.5, amount);\n}mat2 rotate2d(float angle) {\nreturn mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}vec4 getNoise(vec3 p) {\nvec4 noise = bccNoiseDerivatives_XYBeforeZ(p);\nreturn normalizeNoise(noise, 0.2500);\n}void getCaustics(vec2 uv, out vec4 outNoise, out vec3 outColor) {\nvec2 aspect = vec2(uResolution.x/uResolution.y, 1);vec2 mPos = vec2(0.26716417910447765, 0.6468656716417911) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 drift = vec2(0, 0.0000 * uTime * 0.0125);\nvec2 pos = vec2(0.26716417910447765, 0.6468656716417911) + drift * rotate2d(0.1539 * -2. * PI);\nfloat mDist = ease(0, max(0.,1. - distance(uv * aspect, mPos * aspect) * 4. * (1. - 1.0000)));if(0 == 1) {\nmDist = max(0., (0.5 - mDist));\n}uv -= pos;\nuv = uv * aspect * rotate2d(0.1539 * 2. * PI) * vec2(1. - 0.9000, 1.) * 16.0 * 0.4920;float refraction = mix(0.25, 1.3, 0.5000);vec3 p = vec3(uv, uTime * 0.05);\nvec4 noise = getNoise(p);\nvec4 baseNoise = noise;\nvec4 balanceNoise = getNoise(p - vec3(baseNoise.xyz / 32.0) * refraction);\nnoise = getNoise(p - vec3(balanceNoise.xyz / 16.0) * refraction);float balancer = (0.5 + 0.5 * balanceNoise.w);\nfloat normalized = pow(0.5 + 0.5 * noise.w, 2.);\nfloat value = mix(0., normalized + 0.2 * (1.0 - normalized), balancer * mDist);\noutNoise = baseNoise * mDist;\noutColor = vec3(1, 0.9450980392156862, 0.7411764705882353) * value;\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec4 causticNoise;\nvec3 causticColor;\ngetCaustics(uv, causticNoise, causticColor);\nvec4 color = texture(uTexture, uv + causticNoise.xy * 0.01 * 0.0000);\nif(0 > 0) {\nvec3 blended = blend(0, color.rgb, causticColor);\ncolor.rgb = mix(color.rgb, blended, 1.0000);\n} else {\ncolor.rgb = causticColor * 1.0000;\n}\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect2"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"vignette","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"parentLayer":"bf1d9f9b-0c06-4505-bec2-dc0e3a8c5a25","animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nin vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform vec2 uResolution;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn src + dst;\n}out vec4 fragColor;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}\nvoid main() {\nvec2 uv = vTextureCoord;\nvec4 bg = texture(uTexture, uv);\nfloat luma = dot(bg.rgb, vec3(0.299, 0.587, 0.114));\nfloat displacement = (luma - 0.5) * 0.0000 * 0.5;\nvec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1.0);\nvec2 skew = vec2(0.5000, 1.0 - 0.5000);\nfloat halfRadius = 1.3600 * 0.5;\nfloat innerEdge = halfRadius - 3.4500 * halfRadius * 0.5;\nfloat outerEdge = halfRadius + 3.4500 * halfRadius * 0.5;\nvec2 pos = vec2(0.38208955223880603, 0.997910447761194);\nconst float TWO_PI = 6.28318530718;\nvec2 scaledUV = uv * aspectRatio * rot(0.4698 * TWO_PI) * skew;\nvec2 scaledPos = pos * aspectRatio * rot(0.4698 * TWO_PI) * skew;\nfloat radius = distance(scaledUV, scaledPos);\nfloat falloff = smoothstep(innerEdge + displacement, outerEdge + displacement, radius);\nvec3 finalColor;vec3 blended = blend(1, vec3(0, 0, 0), bg.rgb);\nfinalColor = mix(bg.rgb, blended, falloff * 1.0000);float alpha = max(bg.a, falloff * 1.0000);\nvec4 color = mix(bg * (1.-falloff), vec4(finalColor * alpha, alpha), 1.0000);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect3"},{"breakpoints":[{"props":{"height":908.9,"left":-0.005,"top":-0.002111111111111111},"min":992,"max":null,"name":"Desktop"},{"name":"Tablet","max":991,"min":576,"props":{"left":-0.030989583333333334,"height":1039.2,"top":-0.0119140625}}],"visible":true,"locked":false,"aspectRatio":1.6,"layerName":"","userDownsample":1,"isElement":true,"opacity":0.35,"effects":["304da7ce-53ab-46cd-9f2b-e3f2b9b522fd","bf1d9f9b-0c06-4505-bec2-dc0e3a8c5a25"],"displace":0,"trackMouse":0,"anchorPoint":"topLeft","mouseMomentum":0,"blendMode":"ADD","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"maskDepthLayer":1,"dispersion":0,"axisTilt":0,"states":{"appear":[],"scroll":[],"hover":[]},"layerType":"shape","width":1445.2,"widthMode":"fixed","height":908.9,"heightMode":"fixed","left":-0.005,"leftMode":"relative","top":-0.002111111111111111,"topMode":"relative","rotation":0,"trackAxes":"xy","borderRadius":0,"gradientAngle":1.25,"strokeWidth":0,"coords":[[0,0],[1445.2,0],[1445.2,908.9],[0,908.9]],"fill":["transparent"],"fitToCanvas":1,"gradientType":"linear","type":"rectangle","stroke":["#000000"],"numSides":3,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nin vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform vec2 uMousePos;\nuniform sampler2D uBgTexture;\nuniform sampler2D uTexture;\nuniform int uSampleBg;vec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn src + dst;\n}const float STEPS = 24.0;\nconst float PI = 3.1415926;out vec4 fragColor;vec4 getNormalOutput(vec4 color, vec4 background) {\nvec3 unpremultColor = color.rgb / max(color.a, 0.0001);\nvec3 blendedColor = blend(1, unpremultColor, background.rgb);\ncolor = vec4(blendedColor, 1.0) * (color.a * 0.3500);\ncolor = color + background * (1.0 - color.a);\nreturn color;\n}vec4 getOutputByMode(vec4 color, vec4 background) {\nreturn getNormalOutput(color, background);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0000);uv -= pos;vec4 background = vec4(0);\nif(uSampleBg == 1) {\nbackground = texture(uBgTexture, vTextureCoord);\n}\nvec4 color = texture(uTexture, uv);vec4 col = getOutputByMode(color, background);fragColor = col;\n}"],"compiledVertexShaders":["#version 300 es\nprecision highp float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;\nuniform vec2 uMousePos;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\nfloat angleX = uMousePos.y * 0.5 - 0.25;\nfloat angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0,\n0.0, cos(angleX), -sin(angleX), 0.0,\n0.0, sin(angleX), cos(angleX), 0.0,\n0.0, 0.0, 0.0, 1.0);\nmat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0,\n0.0, 1.0, 0.0, 0.0,\n-sin(angleY), 0.0, cos(angleY), 0.0,\n0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY;\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz;\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"uniforms":{}},"id":"shape"}],"options":{"name":"Untitled project","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false},"version":"1.5.3","id":"lSaJxSLUUIw9cvexrGSl"}
